<!DOCTYPE html>
<html>

<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no">

    
    <title>Spring | Likexiao Blogs</title>

    <meta name="description" content="&lt;h1 id=&#34;Spring&#34;&gt;&lt;a href=&#34;#Spring&#34; class=&#34;headerlink&#34; title=&#34;Spring&#34;&gt;&lt;/a&gt;Spring&lt;/h1&gt;&lt;h2 id=&#34;什么是-Spring-框架&#34;&gt;&lt;a href=&#34;#什么是-Spring-框架&#34; class=&#34;headerlink&#34; title=&#34;什么是 Spring 框架?&#34;&gt;&lt;/a&gt;什么是 Spring 框架?&lt;/h2&gt;&lt;p&gt;Spring 是一款开源的轻量级 Java 开发框架，旨在提高开发人员的开发效率以及系统的可维护性。一般说 Spring 框架指的都是 Spring Framework，它是很多模块的集合，使用这些模块可以很方便地协助我们进行开发。&lt;/p&gt;
&lt;p&gt;Spring 最核心的思想就是不重新造轮子，开箱即用！&lt;/p&gt;">
    <meta name="keywords" content="">

    

    <meta property="og:locale" content="zh-CN,en,default" />
    <meta property="og:type" content="article" />
    <meta property="og:title" content= "Spring | Likexiao Blogs"  />
    <meta property="og:description" content= "&lt;h1 id=&#34;Spring&#34;&gt;&lt;a href=&#34;#Spring&#34; class=&#34;headerlink&#34; title=&#34;Spring&#34;&gt;&lt;/a&gt;Spring&lt;/h1&gt;&lt;h2 id=&#34;什么是-Spring-框架&#34;&gt;&lt;a href=&#34;#什么是-Spring-框架&#34; class=&#34;headerlink&#34; title=&#34;什么是 Spring 框架?&#34;&gt;&lt;/a&gt;什么是 Spring 框架?&lt;/h2&gt;&lt;p&gt;Spring 是一款开源的轻量级 Java 开发框架，旨在提高开发人员的开发效率以及系统的可维护性。一般说 Spring 框架指的都是 Spring Framework，它是很多模块的集合，使用这些模块可以很方便地协助我们进行开发。&lt;/p&gt;
&lt;p&gt;Spring 最核心的思想就是不重新造轮子，开箱即用！&lt;/p&gt;" />
    <meta property="og:url" content="https://likexiao.github.io/2022/06/15/%E5%85%AB%E8%82%A1%E6%96%87/10.Spring/index.html" />
    <meta property="og:site_name" content="" />
    <meta property="article:author" content="Likexiao" />
    <meta property="article:publisher" content="" />
    <meta property="og:description" content="&lt;h1 id=&#34;Spring&#34;&gt;&lt;a href=&#34;#Spring&#34; class=&#34;headerlink&#34; title=&#34;Spring&#34;&gt;&lt;/a&gt;Spring&lt;/h1&gt;&lt;h2 id=&#34;什么是-Spring-框架&#34;&gt;&lt;a href=&#34;#什么是-Spring-框架&#34; class=&#34;headerlink&#34; title=&#34;什么是 Spring 框架?&#34;&gt;&lt;/a&gt;什么是 Spring 框架?&lt;/h2&gt;&lt;p&gt;Spring 是一款开源的轻量级 Java 开发框架，旨在提高开发人员的开发效率以及系统的可维护性。一般说 Spring 框架指的都是 Spring Framework，它是很多模块的集合，使用这些模块可以很方便地协助我们进行开发。&lt;/p&gt;
&lt;p&gt;Spring 最核心的思想就是不重新造轮子，开箱即用！&lt;/p&gt;" />
    <meta name="twitter:title" content="Spring | Likexiao Blogs"/>
    <meta name="twitter:description" content="&lt;h1 id=&#34;Spring&#34;&gt;&lt;a href=&#34;#Spring&#34; class=&#34;headerlink&#34; title=&#34;Spring&#34;&gt;&lt;/a&gt;Spring&lt;/h1&gt;&lt;h2 id=&#34;什么是-Spring-框架&#34;&gt;&lt;a href=&#34;#什么是-Spring-框架&#34; class=&#34;headerlink&#34; title=&#34;什么是 Spring 框架?&#34;&gt;&lt;/a&gt;什么是 Spring 框架?&lt;/h2&gt;&lt;p&gt;Spring 是一款开源的轻量级 Java 开发框架，旨在提高开发人员的开发效率以及系统的可维护性。一般说 Spring 框架指的都是 Spring Framework，它是很多模块的集合，使用这些模块可以很方便地协助我们进行开发。&lt;/p&gt;
&lt;p&gt;Spring 最核心的思想就是不重新造轮子，开箱即用！&lt;/p&gt;"/>
    <script type="application/ld+json">
        {
            "description": "&lt;h1 id=&#34;Spring&#34;&gt;&lt;a href=&#34;#Spring&#34; class=&#34;headerlink&#34; title=&#34;Spring&#34;&gt;&lt;/a&gt;Spring&lt;/h1&gt;&lt;h2 id=&#34;什么是-Spring-框架&#34;&gt;&lt;a href=&#34;#什么是-Spring-框架&#34; class=&#34;headerlink&#34; title=&#34;什么是 Spring 框架?&#34;&gt;&lt;/a&gt;什么是 Spring 框架?&lt;/h2&gt;&lt;p&gt;Spring 是一款开源的轻量级 Java 开发框架，旨在提高开发人员的开发效率以及系统的可维护性。一般说 Spring 框架指的都是 Spring Framework，它是很多模块的集合，使用这些模块可以很方便地协助我们进行开发。&lt;/p&gt;
&lt;p&gt;Spring 最核心的思想就是不重新造轮子，开箱即用！&lt;/p&gt;",
            "author": { "@type": "Person", "name": "Likexiao" },
            "@type": "BlogPosting",
            "url": "https://likexiao.github.io/2022/06/15/%E5%85%AB%E8%82%A1%E6%96%87/10.Spring/index.html",
            "publisher": {
            "@type": "Organization",
            "logo": {
                "@type": "ImageObject",
                "url": "https://likexiao.github.ioundefined"
            },
            "name": "Likexiao"
            },
            "headline": "Spring | Likexiao Blogs",
            "datePublished": "2022-06-15T13:08:10.000Z",
            "mainEntityOfPage": {
                "@type": "WebPage",
                "@id": "https://likexiao.github.io/2022/06/15/%E5%85%AB%E8%82%A1%E6%96%87/10.Spring/index.html"
            },
            "@context": "http://schema.org"
        }
    </script>




    

    

    

    

    
    <link rel="icon" href="data:image/svg+xml,<svg xmlns=%22http://www.w3.org/2000/svg%22 viewBox=%220 0 100 100%22><text y=%22.9em%22 font-size=%2290%22>🎮</text></svg>">
    

    

    

    
<link rel="stylesheet" href="/dist/build.css?v=1654266144177.css">


    
<link rel="stylesheet" href="/dist/custom.css?v=1654266144177.css">


    <script>
        window.isPost = true
        window.aomori = {
            
            
            
        }
        window.aomori_logo_typed_animated = true
        window.aomori_search_algolia = false

    </script>

<meta name="generator" content="Hexo 6.3.0"></head>

<body>

    <div class="container">
    <header class="header">
        <div class="header-type">
            
            <div class="header-type-inner">
                
                    <div id="typed-strings" style="display:none">
                        <p>Likexiao Blogs</p>
                    </div>
                    <a class="header-type-title" id="typed" href="/"></a>
                
    
                
            </div>
        </div>
        <div class="header-menu">
            <div class="header-menu-inner">
                
            </div>
            <div class="header-menu-social">
                
            </div>
        </div>

        <div class="header-menu-mobile">
            <div class="header-menu-mobile-inner" id="mobile-menu-open">
                <i class="icon icon-menu"></i>
            </div>
        </div>
    </header>

    <div class="header-menu-mobile-menu">
        <div class="header-menu-mobile-menu-bg"></div>
        <div class="header-menu-mobile-menu-wrap">
            <div class="header-menu-mobile-menu-inner">
                <div class="header-menu-mobile-menu-close" id="mobile-menu-close">
                    <i class="icon icon-cross"></i>
                </div>
                <div class="header-menu-mobile-menu-list">
                    
                </div>
            </div>
        </div>
    </div>

</div>

    <div class="container">
        <div class="main">
            <section class="inner">
                <section class="inner-main">
                    <div class="post">
    <article id="post-clb4fvi0s000ftotxes41fmss" class="article article-type-post" itemscope
    itemprop="blogPost">

    <div class="article-inner">

        
          
        
        
        

        
        <header class="article-header">
            
  
    <h1 class="article-title" itemprop="name">
      Spring
    </h1>
  

        </header>
        

        <div class="article-more-info article-more-info-post hairline">

            <div class="article-date">
  <time datetime="2022-06-15T13:08:10.000Z" itemprop="datePublished">2022-06-15</time>
</div>

            

            

            
            <div class="article-busuanzi">
                <span id="busuanzi_value_page_pv">N</span> 人看过
            </div>
            

        </div>

        <div class="article-entry post-inner-html hairline" itemprop="articleBody">
            <h1 id="Spring"><a href="#Spring" class="headerlink" title="Spring"></a>Spring</h1><h2 id="什么是-Spring-框架"><a href="#什么是-Spring-框架" class="headerlink" title="什么是 Spring 框架?"></a>什么是 Spring 框架?</h2><p>Spring 是一款开源的轻量级 Java 开发框架，旨在提高开发人员的开发效率以及系统的可维护性。一般说 Spring 框架指的都是 Spring Framework，它是很多模块的集合，使用这些模块可以很方便地协助我们进行开发。</p>
<p>Spring 最核心的思想就是不重新造轮子，开箱即用！</p>
<span id="more"></span>


<h2 id="列举一些重要的-Spring-模块？"><a href="#列举一些重要的-Spring-模块？" class="headerlink" title="列举一些重要的 Spring 模块？"></a>列举一些重要的 Spring 模块？</h2><ul>
<li><p><strong>Spring Core</strong></p>
<p> <strong>Spring 其他所有的功能基本都需要依赖于该模块，主要提供 IoC 依赖注入功能的支持。</strong></p>
</li>
<li><p>Spring Aspects</p>
<p>该模块为与 AspectJ 的集成提供支持。</p>
</li>
<li><p><strong>Spring AOP</strong></p>
<p>提供了面向切面的编程实现。</p>
</li>
<li><p>Spring Data Access</p>
<ul>
<li><strong>spring-jdbc : 提供了对数据库访问的抽象 JDBC。不同的数据库都有自己独立的 API 用于操作数据库，而 Java 程序只需要和 JDBC API 交互，这样就屏蔽了数据库的影响。</strong></li>
<li>spring-tx : 提供对事务的支持。</li>
<li>spring-orm : 提供对 Hibernate 等 ORM 框架的支持。</li>
<li>spring-oxm ： 提供对 Castor 等 OXM 框架的支持。</li>
<li>spring-jms : Java 消息服务。</li>
</ul>
</li>
<li><p><strong>Spring Web</strong></p>
<ul>
<li><strong>spring-web ：对 Web 功能的实现提供一些最基础的支持。</strong></li>
<li><strong>spring-webmvc ： 提供对 Spring MVC 的实现。</strong></li>
<li>spring-websocket ： 提供了对 WebSocket 的支持，WebSocket 可以让客户端和服务端进行双向通信。</li>
<li>spring-webflux ：提供对 WebFlux 的支持。WebFlux 是 Spring Framework 5.0 中引入的新的响应式框架。与 Spring MVC 不同，它不需要 Servlet API，是完全异步.</li>
</ul>
</li>
<li><p>Spring Test</p>
</li>
</ul>
<h2 id="Spring-Spring-MVC-Spring-Boot-之间什么关系"><a href="#Spring-Spring-MVC-Spring-Boot-之间什么关系" class="headerlink" title="Spring,Spring MVC,Spring Boot 之间什么关系?"></a>Spring,Spring MVC,Spring Boot 之间什么关系?</h2><p>Spring MVC 是 Spring 中的一个很重要的模块，主要赋予 Spring 快速构建 MVC 架构的 Web 程序的能力。MVC 是模型(Model)、视图(View)、控制器(Controller)的简写，其核心思想是通过将业务逻辑、数据、显示分离来组织代码。</p>
<p>Spring Boot 只是简化了配置，如果你需要构建 MVC 架构的 Web 程序，你还是需要使用 Spring MVC 作为 MVC 框架，只是说 Spring Boot 帮你简化了 Spring MVC 的很多配置，真正做到开箱即用！</p>
<h2 id="Spring-IOC-amp-AOP"><a href="#Spring-IOC-amp-AOP" class="headerlink" title="Spring IOC &amp; AOP"></a>Spring IOC &amp; AOP</h2><h3 id="IOC"><a href="#IOC" class="headerlink" title="IOC"></a>IOC</h3><p><strong>IoC（Inverse of Control:控制反转）</strong> <strong>是一种设计思想</strong>，而不是一个具体的技术实现。IoC 的思想就是将原本在程序中手动创建对象的控制权，交由 Spring 框架来管理。不过， IoC 并非 Spring 特有，在其他语言中也有应用(直言是面向对象编程的语言都可以实现该功能)。</p>
<p>将对象之间的相互依赖关系交给 IoC 容器来管理，并由 IoC 容器完成对象的注入。这样可以很大程度上简化应用的开发，把应用从复杂的依赖关系中解放出来。 IoC 容器就像是一个工厂一样，当我们需要创建一个对象的时候，只需要配置好配置文件&#x2F;注解即可，完全不用考虑对象是如何被创建出来的。</p>
<h3 id="AOP"><a href="#AOP" class="headerlink" title="AOP"></a>AOP</h3><p>AOP(Aspect-Oriented Programming:面向切面编程)能够将那些与业务无关，却为业务模块所共同调用的逻辑或责任（例如事务处理、日志管理、权限控制等）封装起来，便于减少系统的重复代码，降低模块间的耦合度，并有利于未来的可拓展性和可维护性。</p>
<h4 id="Spring-AOP-和-AspectJ-AOP-有什么区别？"><a href="#Spring-AOP-和-AspectJ-AOP-有什么区别？" class="headerlink" title="Spring AOP 和 AspectJ AOP 有什么区别？"></a>Spring AOP 和 AspectJ AOP 有什么区别？</h4><p><strong>Spring AOP 属于运行时增强，而 AspectJ 是编译时增强。</strong> Spring AOP 基于代理(Proxying)，而 AspectJ 基于字节码操作(Bytecode Manipulation)。</p>
<h2 id="Spring-bean"><a href="#Spring-bean" class="headerlink" title="Spring bean"></a>Spring bean</h2><p>bean 代指的就是那些被 IoC 容器所管理的对象</p>
<h3 id="bean-的作用域有哪些"><a href="#bean-的作用域有哪些" class="headerlink" title="bean 的作用域有哪些?"></a>bean 的作用域有哪些?</h3><ul>
<li><strong>singleton</strong> : 唯一 bean 实例，Spring 中的 bean 默认都是单例的，对单例设计模式的应用。</li>
<li><strong>prototype</strong> : 每次请求都会创建一个新的 bean 实例。</li>
<li><strong>request</strong> : 每一次 HTTP 请求都会产生一个新的 bean，该 bean 仅在当前 HTTP request 内有效。</li>
<li><strong>session</strong> : 每一次来自新 session 的 HTTP 请求都会产生一个新的 bean，该 bean 仅在当前 HTTP session 内有效。</li>
</ul>
<h3 id="单例-bean-的线程安全问题了解吗？"><a href="#单例-bean-的线程安全问题了解吗？" class="headerlink" title="单例 bean 的线程安全问题了解吗？"></a>单例 bean 的线程安全问题了解吗？</h3><p>单例 bean 存在线程问题，主要是因为当多个线程操作同一个对象的时候是存在资源竞争的。不过，大部分 bean 实际都是无状态（没有实例变量）的（比如 Dao、Service），这种情况下， bean 是线程安全的。</p>
<p>常见的有两种解决办法：</p>
<ol>
<li>在 bean 中尽量避免定义可变的成员变量。</li>
<li>在类中定义一个 <code>ThreadLocal</code> 成员变量，将需要的可变成员变量保存在 <code>ThreadLocal</code> 中（推荐的一种方式）。</li>
</ol>
<h3 id="Component-和-Bean-的区别是什么？"><a href="#Component-和-Bean-的区别是什么？" class="headerlink" title="@Component 和 @Bean 的区别是什么？"></a>@Component 和 @Bean 的区别是什么？</h3><ol>
<li><code>@Component</code> 注解作用于类，而<code>@Bean</code>注解作用于方法。</li>
<li><code>@Component</code>通常是通过类路径扫描来自动侦测以及自动装配到 Spring 容器中。<code>@Bean</code> 注解通常是我们在标有该注解的方法中定义产生这个 bean,<code>@Bean</code>告诉了 Spring 这是某个类的实例，当我需要用它的时候还给我。</li>
<li><code>@Bean</code> 注解比 <code>@Component</code> 注解的自定义性更强，而且很多地方我们只能通过 <code>@Bean</code> 注解来注册 bean。比如当我们引用第三方库中的类需要装配到 <code>Spring</code>容器时，则只能通过 <code>@Bean</code>来实现。</li>
</ol>
<h3 id="将一个类声明为-bean-的注解有哪些"><a href="#将一个类声明为-bean-的注解有哪些" class="headerlink" title="将一个类声明为 bean 的注解有哪些?"></a>将一个类声明为 bean 的注解有哪些?</h3><p>我们一般使用 <code>@Autowired</code> 注解自动装配 bean</p>
<ul>
<li><code>@Component</code> ：通用的注解，可标注任意类为 <code>Spring</code> 组件。如果一个 Bean 不知道属于哪个层，可以使用<code>@Component</code> 注解标注。</li>
<li><code>@Repository</code> : 对应持久层即 Dao 层，主要用于数据库相关操作。</li>
<li><code>@Service</code> : 对应服务层，主要涉及一些复杂的逻辑，需要用到 Dao 层。</li>
<li><code>@Controller</code> : 对应 Spring MVC 控制层，主要功能是接受用户请求并调用 Service 层返回数据给前端页面。</li>
</ul>
<h2 id="Spring-MVC"><a href="#Spring-MVC" class="headerlink" title="Spring MVC"></a>Spring MVC</h2><p>MVC 是模型(Model)、视图(View)、控制器(Controller)的简写，其核心思想是通过将业务逻辑、数据、显示分离来组织代码。</p>
<h3 id="工作原理"><a href="#工作原理" class="headerlink" title="工作原理"></a>工作原理</h3><p><img src="/picture/6.png"></p>
<ol>
<li><strong>客户端（浏览器）发送请求，直接请求到 <code>DispatcherServlet</code>。</strong></li>
<li><strong><code>DispatcherServlet</code> 根据请求信息调用 <code>HandlerMapping</code>，解析请求对应的 <code>Handler</code>。</strong></li>
<li><strong>解析到对应的 <code>Handler</code>（也就是我们平常说的 <code>Controller</code> 控制器）后，开始由 <code>HandlerAdapter</code> 适配器处理。</strong></li>
<li><strong><code>HandlerAdapter</code> 会根据 <code>Handler</code>来调用真正的处理器开处理请求，并处理相应的业务逻辑。</strong></li>
<li>处理器处理完业务后，会返回一个 <code>ModelAndView</code> 对象，<code>Model</code> 是返回的数据对象，<code>View</code> 是个逻辑上的 <code>View</code>。</li>
<li><code>ViewResolver</code> 会根据逻辑 <code>View</code> 查找实际的 <code>View</code>。</li>
<li><code>DispaterServlet</code> 把返回的 <code>Model</code> 传给 <code>View</code>（视图渲染）。</li>
<li>把 <code>View</code> 返回给请求者（浏览器）</li>
</ol>
<h2 id="Spring-框架中用到了哪些设计模式？"><a href="#Spring-框架中用到了哪些设计模式？" class="headerlink" title="Spring 框架中用到了哪些设计模式？"></a>Spring 框架中用到了哪些设计模式？</h2><ul>
<li><strong>工厂设计模式</strong> : Spring 使用工厂模式通过 <code>BeanFactory</code>、<code>ApplicationContext</code> 创建 bean 对象。</li>
<li><strong>代理设计模式</strong> : Spring AOP 功能的实现。</li>
<li><strong>单例设计模式</strong> : Spring 中的 Bean 默认都是单例的。</li>
<li><strong>模板方法模式</strong> : Spring 中 <code>jdbcTemplate</code>、<code>hibernateTemplate</code> 等以 Template 结尾的对数据库操作的类，它们就使用到了模板模式。</li>
<li><strong>包装器设计模式</strong> : 我们的项目需要连接多个数据库，而且不同的客户在每次访问中根据需要会去访问不同的数据库。这种模式让我们可以根据客户的需求能够动态切换不同的数据源。</li>
<li><strong>观察者模式:</strong> Spring 事件驱动模型就是观察者模式很经典的一个应用。</li>
<li><strong>适配器模式</strong> : Spring AOP 的增强或通知(Advice)使用到了适配器模式、spring MVC 中也是用到了适配器模式适配<code>Controller</code>。</li>
</ul>
<h2 id="Spring-事务"><a href="#Spring-事务" class="headerlink" title="Spring 事务"></a>Spring 事务</h2><h3 id="Spring-管理事务的方式有几种？"><a href="#Spring-管理事务的方式有几种？" class="headerlink" title="Spring 管理事务的方式有几种？"></a>Spring 管理事务的方式有几种？</h3><ul>
<li><strong>编程式事务</strong> ： 在代码中硬编码(不推荐使用) : 通过 <code>TransactionTemplate</code>或者 <code>TransactionManager</code> 手动管理事务，实际应用中很少使用，但是对于你理解 Spring 事务管理原理有帮助。</li>
<li><strong>声明式事务</strong> ： 在 XML 配置文件中配置或者直接基于注解（推荐使用） : 实际是通过 AOP 实现（基于<code>@Transactional</code> 的全注解方式使用最多）</li>
</ul>
<h3 id="Spring中事务的传播行为"><a href="#Spring中事务的传播行为" class="headerlink" title="Spring中事务的传播行为"></a>Spring中事务的传播行为</h3><p>当事务方法被另一个事务方法调用时，必须指定事务应该如何传播。</p>
<ul>
<li><p><strong>propagation_require(默认)</strong></p>
<p><strong>如果当前存在事务，则加入该事务；如果当前没有事务，则创建一个新的事务。</strong></p>
</li>
<li><p><strong>propagation_require_new</strong></p>
<p><strong>创建一个新的事务，如果当前存在事务，则把当前事务挂起。也就是说不管外部方法是否开启事务，<code>Propagation.REQUIRES_NEW</code>修饰的内部方法会新开启自己的事务，且开启的事务相互独立，互不干扰。</strong></p>
</li>
<li><p><strong>propagation_nested</strong></p>
<p><strong>如果当前存在事务，则创建一个事务作为当前事务的嵌套事务来运行 , 如果没有 , 就等价于propagation_require</strong></p>
</li>
<li><p><strong>propagation_mandatory</strong></p>
<p><strong>如果当前存在事务，则加入该事务；如果当前没有事务，则抛出异常。</strong></p>
</li>
<li><p>propagation_supports</p>
<p>如果当前存在事务，则加入该事务；如果当前没有事务，则以非事务的方式继续运行。</p>
</li>
<li><p>propagation_not_supports</p>
<p>以非事务方式运行，如果当前存在事务，则把当前事务挂起。</p>
</li>
<li><p>propagation_never</p>
<p>以非事务方式运行，如果当前存在事务，则抛出异常。</p>
</li>
</ul>
<h3 id="Spring-事务中的隔离级别有哪几种"><a href="#Spring-事务中的隔离级别有哪几种" class="headerlink" title="Spring 事务中的隔离级别有哪几种?"></a>Spring 事务中的隔离级别有哪几种?</h3><ul>
<li>default : 使用后端数据库默认的隔离级别</li>
<li>read_uncommitted</li>
<li>read_committed</li>
<li>repeatable_read</li>
<li>serializable</li>
</ul>
<h2 id="Spring-x2F-Spring-Boot常用注解"><a href="#Spring-x2F-Spring-Boot常用注解" class="headerlink" title="Spring&#x2F;Spring Boot常用注解"></a>Spring&#x2F;Spring Boot常用注解</h2><h3 id="SpringBootApplication"><a href="#SpringBootApplication" class="headerlink" title="@SpringBootApplication"></a><code>@SpringBootApplication</code></h3><p><em>这个注解是 Spring Boot 项目的基石，创建 SpringBoot 项目之后会默认在主类加上。</em></p>
<p>我们可以把 <code>@SpringBootApplication</code>看作是 <code>@Configuration</code>、<code>@EnableAutoConfiguration</code>、<code>@ComponentScan</code> 注解的集合。</p>
<ul>
<li><code>@EnableAutoConfiguration</code>：启用 SpringBoot 的自动配置机制</li>
<li><code>@ComponentScan</code>： 扫描被<code>@Component</code> (<code>@Service</code>,<code>@Controller</code>)注解的 bean，注解默认会扫描该类所在的包下所有的类。</li>
<li><code>@Configuration</code>：允许在 Spring 上下文中注册额外的 bean 或导入其他配置类</li>
</ul>
<h3 id="Spring-Bean-相关"><a href="#Spring-Bean-相关" class="headerlink" title="Spring Bean 相关"></a>Spring Bean 相关</h3><h4 id="Autowired"><a href="#Autowired" class="headerlink" title="@Autowired"></a><code>@Autowired</code></h4><p>自动导入对象到类中，被注入进的类同样要被 Spring 容器管理比如：Service 类注入到 Controller 类中。</p>
<h4 id="Component-Repository-Service-Controller"><a href="#Component-Repository-Service-Controller" class="headerlink" title="@Component,@Repository,@Service, @Controller"></a><code>@Component</code>,<code>@Repository</code>,<code>@Service</code>, <code>@Controller</code></h4><h4 id="Scope"><a href="#Scope" class="headerlink" title="@Scope"></a><code>@Scope</code></h4><p><strong>四种常见的 Spring Bean 的作用域：</strong></p>
<ul>
<li>singleton : 唯一 bean 实例，Spring 中的 bean 默认都是单例的。</li>
<li>prototype : 每次请求都会创建一个新的 bean 实例。</li>
<li>request : 每一次 HTTP 请求都会产生一个新的 bean，该 bean 仅在当前 HTTP request 内有效。</li>
<li>session : 每一个 HTTP Session 会产生一个新的 bean，该 bean 仅在当前 HTTP session 内有效。</li>
</ul>
<h4 id="Configuration"><a href="#Configuration" class="headerlink" title="@Configuration"></a><code>@Configuration</code></h4><p>一般用来声明配置类，可以使用 <code>@Component</code>注解替代，不过使用<code>@Configuration</code>注解声明配置类更加语义化。</p>
<h3 id="处理常见的-HTTP-请求类型"><a href="#处理常见的-HTTP-请求类型" class="headerlink" title="处理常见的 HTTP 请求类型"></a>处理常见的 HTTP 请求类型</h3><ul>
<li><strong>GET</strong> ：请求从服务器获取特定资源。</li>
<li><strong>POST</strong> ：在服务器上创建一个新的资源。</li>
<li><strong>PUT</strong> ：更新服务器上的资源（客户端提供更新后的整个资源）。</li>
<li><strong>DELETE</strong> ：从服务器删除特定的资源。</li>
</ul>
<h3 id="前后端传值"><a href="#前后端传值" class="headerlink" title="前后端传值"></a>前后端传值</h3><p>**一个请求方法只可以有一个<code>@RequestBody</code>，但是可以有多个<code>@RequestParam</code>和<code>@PathVariable</code>**。</p>
<h4 id="PathVariable-和-RequestParam"><a href="#PathVariable-和-RequestParam" class="headerlink" title="@PathVariable 和 @RequestParam"></a><code>@PathVariable</code> 和 <code>@RequestParam</code></h4><p><code>@PathVariable</code>用于获取路径参数，<code>@RequestParam</code>用于获取查询参数。</p>
<h4 id="RequestBody"><a href="#RequestBody" class="headerlink" title="@RequestBody"></a><code>@RequestBody</code></h4><p>用于读取 Request 请求（可能是 POST,PUT,DELETE,GET 请求）的 body 部分并且<strong>Content-Type 为 application&#x2F;json</strong> 格式的数据，接收到数据之后会自动将数据绑定到 Java 对象上去。</p>
<h3 id="读取配置信息"><a href="#读取配置信息" class="headerlink" title="读取配置信息"></a>读取配置信息</h3><h4 id="Value-常用"><a href="#Value-常用" class="headerlink" title="@Value(常用)"></a><code>@Value</code>(常用)</h4><p>使用 <code>@Value(&quot;$&#123;property&#125;&quot;)</code> 读取比较简单的配置信息</p>
<h4 id="ConfigurationProperties-常用"><a href="#ConfigurationProperties-常用" class="headerlink" title="@ConfigurationProperties(常用)"></a><code>@ConfigurationProperties</code>(常用)</h4><p>通过<code>@ConfigurationProperties</code>读取配置信息并与 bean 绑定。</p>
<h3 id="AspectJ切面注解通知"><a href="#AspectJ切面注解通知" class="headerlink" title="AspectJ切面注解通知"></a>AspectJ切面注解通知</h3><ul>
<li>@Before: 前置通知, 在方法执行之前执行</li>
<li>@After: 后置通知, 在方法执行之后执行 。</li>
<li>@AfterRunning: 返回通知, 在方法返回结果之后执行</li>
<li>@AfterThrowing: 异常通知, 在方法抛出异常之后</li>
<li>@Around: 环绕通知, 围绕着方法执行</li>
</ul>
<h3 id="循环依赖问题"><a href="#循环依赖问题" class="headerlink" title="循环依赖问题"></a>循环依赖问题</h3><h4 id="单例对象中的set方法的循环依赖"><a href="#单例对象中的set方法的循环依赖" class="headerlink" title="单例对象中的set方法的循环依赖"></a>单例对象中的set方法的循环依赖</h4><ul>
<li><p>一级缓存的作用 : 限制bean在beanFactory中只存一份 , 即实现singleton scope</p>
<ul>
<li><p>一级缓存无法解决循环依赖的问题</p>
<p><img src="/picture/9.png"></p>
<p>先调用了a的getBean , 然后当a运行到了 a.setB , 就会去调用b的getBean , 这样往复就会陷入死循环</p>
</li>
</ul>
</li>
<li><p>二级缓存</p>
</li>
<li><p><img src="/picture/10.png"></p>
<p>在调用a的getBean时,会先将一个半成品的a放入singletonFactories(二级缓存)中,然后去调用a.setB,此时会先去二级缓存查找是否有一个半成品的b,没有再去调用b的getBean,b在运行到b.setA时会去二级缓存中,发现有a的半成品,此时拿到a完成依赖注入和初始化并返回b给a的getBean方法,随后a完成注入并初始化 , 这样就解决了循环依赖的问题</p>
<p><strong>但是,在使用代理对象进行功能增强的时候,会出现问题 , 因为b拿到的是没有增强过的a对象,因此会出现增强功能丢失的问题</strong></p>
<p>如何解决?</p>
<ul>
<li>有一种是提前创建代理对象 , 然后放到二级缓存中 , 但是spring并没有这么做</li>
</ul>
</li>
<li><p>引入三级缓存(earlySingletonObjects)和一个工厂 , <strong>工厂的作用是创建代理对象或者是原始对象</strong></p>
<ul>
<li>工厂创建对象的时机<ul>
<li>有循环依赖,提前创建代理返回</li>
<li>没有循环依赖,还是返回原始对象</li>
</ul>
</li>
</ul>
<p>创建a的实例,<strong>将a的工厂对象放入二级缓存(singletonFactories)</strong>,发生a.setB(),…….,返回b的代理对象pb,<strong>然后去检查三级缓存中有没有a的代理对象,发现有,则不用在此创建a的代理,直接调用即可</strong>,最后把成品对象放入一级缓存</p>
</li>
</ul>
<h4 id="解决构造循环依赖问题"><a href="#解决构造循环依赖问题" class="headerlink" title="解决构造循环依赖问题"></a>解决构造循环依赖问题</h4><ol>
<li>在a创建需要b的构造的时候提供一个b的代理对象,此时a可以顺利初始化.这时调用b的构造方法可以从一级缓存中取到a对象,顺利创建</li>
<li>与第一种唯一的不同就是需要b的构造的时候注入一个ObjectFactory来起到推迟b的创建的作用</li>
</ol>

        </div>

    </div>

    

    

    

    

    

    
<nav class="article-nav">
  
    <a href="/2022/06/15/%E5%85%AB%E8%82%A1%E6%96%87/1.Java%E5%9F%BA%E7%A1%80/" id="article-nav-newer" class="article-nav-link-wrap">
      <div class="article-nav-caption">下一篇</div>
      <div class="article-nav-title">
        
          Java基础
        
      </div>
    </a>
  
  
    <a href="/2022/06/15/%E5%85%AB%E8%82%A1%E6%96%87/11.MyBatis/" id="article-nav-older" class="article-nav-link-wrap">
      <div class="article-nav-caption">上一篇</div>
      <div class="article-nav-title">MyBatis</div>
    </a>
  
</nav>


    <section class="share">
        <div class="share-title">分享</div>
        <a class="share-item" target="_blank"
            href="https://twitter.com/share?text=Spring - Likexiao Blogs&url=https%3A%2F%2Flikexiao.github.io%2F2022%2F06%2F15%2F%25E5%2585%25AB%25E8%2582%25A1%25E6%2596%2587%2F10.Spring%2F">
            <ion-icon name="logo-twitter"></ion-icon>
        </a>
        <a class="share-item" target="_blank"
            href="https://www.facebook.com/sharer.php?title=Spring - Likexiao Blogs&u=https%3A%2F%2Flikexiao.github.io%2F2022%2F06%2F15%2F%25E5%2585%25AB%25E8%2582%25A1%25E6%2596%2587%2F10.Spring%2F">
            <ion-icon name="logo-facebook"></ion-icon>
        </a>
        <!-- <a class="share-item" target="_blank"
            href="https://service.weibo.com/share/share.php?title=Spring - Likexiao Blogs&url=https://likexiao.github.io/2022/06/15/%E5%85%AB%E8%82%A1%E6%96%87/10.Spring/&pic=">
            <div class="n-icon n-icon-weibo"></div>
        </a> -->
    </section>

</article>
















<script src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>

</div>
                </section>
            </section>

            
            <aside class="sidebar ">
                


<div class="widget" id="widget">
    
      
  <div class="widget-wrap">
    <div class="widget-inner">
      <div class="toc post-toc-html"></div>
    </div>
  </div>

    
      
  <div class="widget-wrap widget-cate">
    <div class="widget-title"><span>Categories</span></div>
    <div class="widget-inner">
      <ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/redis/">redis</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E5%AF%B9%E8%AF%9D/">对话</a></li></ul>
    </div>
  </div>


    
      
  <div class="widget-wrap widget-tags">
    <div class="widget-title"><span>Tags</span></div>
    <div class="widget-inner">
      <ul class="tag-list" itemprop="keywords"><li class="tag-list-item"><a class="tag-list-link" href="/tags/redis/" rel="tag">redis</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E8%AE%A4%E8%AF%86/" rel="tag">认识</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/" rel="tag">设计模式</a></li></ul>
    </div>
  </div>


    
      
  <div class="widget-wrap widget-recent-posts">
    <div class="widget-title"><span>Recent Posts</span></div>
    <div class="widget-inner">
      <ul>
        
          <li>
            <a href="/2022/11/30/dp-core-6/">设计模式六大原则详解</a>
          </li>
        
          <li>
            <a href="/2022/10/11/Docker%E5%AE%89%E8%A3%85%20Redis%E5%AE%B9%E5%99%A8/">Docker 安装 Redis 容器</a>
          </li>
        
          <li>
            <a href="/2022/06/15/%E5%85%AB%E8%82%A1%E6%96%87/1.Java%E5%9F%BA%E7%A1%80/">Java基础</a>
          </li>
        
          <li>
            <a href="/2022/06/15/%E5%85%AB%E8%82%A1%E6%96%87/10.Spring/">Spring</a>
          </li>
        
          <li>
            <a href="/2022/06/15/%E5%85%AB%E8%82%A1%E6%96%87/11.MyBatis/">MyBatis</a>
          </li>
        
      </ul>
    </div>
  </div>

    
      
  <div class="widget-wrap widget-archive">
    <div class="widget-title"><span>Archive</span></div>
    <div class="widget-inner">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2022/">2022</a></li></ul>
    </div>
  </div>


    
</div>

<div id="backtop"><i class="icon icon-arrow-up"></i></div>
            </aside>
            
        </div>
    </div>

    <footer class="footer">
    <div class="footer-wave">
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 1440 320"><path fill="#3c4859" fill-opacity="1" d="M0,160L60,181.3C120,203,240,245,360,240C480,235,600,181,720,186.7C840,192,960,256,1080,261.3C1200,267,1320,213,1380,186.7L1440,160L1440,320L1380,320C1320,320,1200,320,1080,320C960,320,840,320,720,320C600,320,480,320,360,320C240,320,120,320,60,320L0,320Z"></path></svg>
    </div>

    <!-- Please do not remove this -->
    <!-- 开源不易，请勿删除 -->
    <div class="footer-wrap">
        <div class="footer-inner"> 
            Likexiao Blogs &copy; 2022<br>
            Powered By Hexo · Theme By <a href="https://linhong.me/" target="_blank">Aomori</a> · <a href="https://github.com/lh1me/hexo-theme-aomori" target="_blank">Github</a>
        </div>
    </div>

</footer>

<script type="module" src="https://unpkg.com/ionicons@6.0.2/dist/ionicons/ionicons.esm.js"></script>






<script src="/dist/build.js?1654266144177.js"></script>


<script src="/dist/custom.js?1654266144177.js"></script>












<!-- Baidu Analytics-->
<script type="text/javascript">
    var _hmt = _hmt || [];
    (function () {
        var hm = document.createElement("script");
        hm.src = "https://hm.baidu.com/hm.js?5be7083050bcb3ab41dfb4024a26ecb0";
        var s = document.getElementsByTagName("script")[0];
        s.parentNode.insertBefore(hm, s);
    })();
</script>


</body>

</html>